# Модель: Calculation

## 1. Описание

**`Calculation`** — это мощная и гибкая **встраиваемая модель**, предназначенная для декларативного описания сложных финансовых расчетов. **Это не самостоятельная сущность**, а чистая "инструкция по расчету", которая встраивается в другие модели данных.

Архитектура модели поддерживает не только сложные схемы расчета (простые, многоуровневые, условные), но и **правила постобработки**, такие как установка минимальной/максимальной комиссии и математическое округление.

## 2. Назначение и решаемые задачи

Основная цель — создать универсальный "калькулятор", управляемый данными, который может покрыть практически любой бизнес-кейс без необходимости изменять код.

### Ключевые задачи:
- **Декларативное описание**: Описывает "КАК" считать, а не реализует это в коде.
- **Максимальная гибкость**: Поддерживает вложенные правила и постобработку.
- **Переиспользуемость**: Встраивается в любую модель, где нужен динамический расчет.

## 3. Ключевые поля и концепции

Модель состоит из двух основных этапов: **Расчет** и **Постобработка**.

### Этап 1: Расчет
Выполняется с помощью одного из трех видов (`oneof kind`):

- **`Calculation.Simple`**: Самый базовый блок: `fixed_value` + `percent_value`.
- **`Calculation.Tiered`**: Реализует многоуровневые расчеты (`SLAB` или `PROGRESSIVE`).
- **`Calculation.Conditional`**: Реализует логику "if-else", позволяя рекурсивно вкладывать другие `Calculation`.

### Этап 2: Постобработка
После получения "сырого" результата из Этапа 1, к нему применяются правила из необязательного объекта `PostProcessing`:

- **`Calculation.PostProcessing`**:
  - `min_value` / `max_value`: Ограничение результата.
  - `rounding`: Правила математического округления.

## 4. Архитектурная мощь: рекурсия и композиция

Два главных паттерна делают эту модель по-настоящему мощной:

- **Рекурсия с `Conditional`**: Поля `if_true` и `if_false` сами являются `Calculation`, что позволяет строить вложенные деревья решений.
- **Композиция с `CalculationGroup`**: Позволяет описать итоговую сумму как результат сложения нескольких независимых, именованных расчетов.

## 5. Сценарии использования (кейсы)

### Пример 1: Простая комиссия с постобработкой
- **Задача**: "Комиссия 1.5%, но не менее 10 USDT и не более 100 USDT, округленная до 2 знаков".
- **Решение**: Один `Calculation`.
  - `kind`: `simple: { percent_value: "0.015" }`
  - `post_processing`: `{ min_value: "10", max_value: "100", rounding: { kind: HALF_UP, precision: 2 } }`

### Пример 2: Рекурсивное условие
- **Задача**: "Если сумма > 1000, то комиссия 0.1%. Иначе, если сумма > 500, то 0.2%, иначе — 0.3%".
- **Решение**: Вложенный `Conditional`.
  - `kind`: `conditional`:
    - `condition`: `{ value: "1000", kind: EXCLUSIVE }`
    - `if_true`: `Calculation` с `simple: { percent_value: "0.001" }`.
    - `if_false`: **Второй** `Calculation` с `conditional`:
      - `condition`: `{ value: "500", kind: EXCLUSIVE }`
      - `if_true`: `Calculation` с `simple: { percent_value: "0.002" }`.
      - `if_false`: `Calculation` с `simple: { percent_value: "0.003" }`.

### Пример 3: Ультимативный сбор через `CalculationGroup`
- **Задача**: "Итоговый сбор за вывод состоит из: (А) комиссии за обработку, (Б) налога и (В) фиксированной платы за SWIFT. Итоговая сумма не может быть меньше 50 USDT."
- **Решение**: Используется `CalculationGroup`.
  1.  **`calculations["processing_fee"]`**: `Calculation` с прогрессивной шкалой (`tiered`).
  2.  **`calculations["tax_fee"]`**: `Calculation` с простой ставкой (`simple`).
  3.  **`calculations["swift_fee"]`**: `Calculation` с фиксированной суммой (`simple`).
  4.  **`post_processing` (внутри `CalculationGroup`)**: `{ min_value: "50" }`.
- **Как это работает**:
  - Бэкенд выполняет каждый из трех `Calculation` и получает три промежуточных результата.
  - Затем он **суммирует** эти результаты: `total = fee_A + fee_B + fee_C`.
  - К этой **итоговой сумме** `total` он применяет правила из `post_processing` самого `CalculationGroup`.

## 6. Связи с другими моделями

- **`Calculation`** и **`CalculationGroup`** предназначены для **встраивания** в другие модели (`PaymentGatewayCurrency`, `Exchange` и т.д.).
- **`Rounding`**: `Calculation.PostProcessing` **использует** `Rounding` для определения правил округления.
