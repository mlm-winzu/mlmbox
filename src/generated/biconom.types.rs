// This file is @generated by prost-build.
/// UserPolicy определяет набор правил для группы пользователей.
/// Конкретная логика политики (например, требования к верификации) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `UserPolicy`.
pub mod user_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::UserPolicy>,
    }
}
/// Модель данных для пользователя системы
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "2")]
    pub trace_id: u64,
    /// Политика, управляющая поведением пользователя.
    #[prost(uint32, tag = "3")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `User`.
pub mod user {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID пользователя
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (пользователи)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::User>,
    }
}
/// CommunityPolicy определяет набор правил для группы сообществ.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommunityPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CommunityPolicy`.
pub mod community_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CommunityPolicy>,
    }
}
/// Модель данных для сообществ системы
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Community {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "2")]
    pub trace_id: u64,
    /// Политика, управляющая поведением сообщества.
    #[prost(uint32, tag = "3")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Community`.
pub mod community {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID сообщества
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    /// Список сообществ
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        /// Элементы списка (сообщества)
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Community>,
    }
}
/// AccountPolicy определяет набор правил для группы аккаунтов.
/// Конкретная логика политики (например, блокировка всех операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `AccountPolicy`.
pub mod account_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::AccountPolicy>,
    }
}
/// Account является универсальной учетной записью в системе.
/// Он представляет собой абстракцию, которая может ссылаться либо на пользователя (User),
/// либо на сообщество (Community), позволяя им выступать в роли владельцев других сущностей.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    /// Политика, управляющая поведением аккаунта (включая права доступа).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
    /// Тип владельца аккаунта
    #[prost(oneof = "account::Owner", tags = "2, 3")]
    pub owner: ::core::option::Option<account::Owner>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Уникальный ID аккаунта
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный ID пользователя
            #[prost(uint32, tag = "2")]
            UserId(u32),
            /// Уникальный ID сообщества
            #[prost(uint32, tag = "3")]
            CommunityId(u32),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Account>,
    }
    /// Тип владельца аккаунта
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Owner {
        /// Ссылка на пользователя
        #[prost(message, tag = "2")]
        User(super::User),
        /// Ссылка на сообщество
        #[prost(message, tag = "3")]
        Community(super::Community),
    }
}
/// BonusPolicy определяет набор правил для группы бонусов.
/// Конкретная логика расчета и начисления бонуса реализуется на бэкенде
/// и привязывается к этой политике по ее имени или ID.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BonusPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `BonusPolicy`.
pub mod bonus_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::BonusPolicy>,
    }
}
/// Bonus представляет собой справочную информацию о бонусе, существующем в системе.
/// Вся логика его расчета и начисления определяется в связанной BonusPolicy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bonus {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя бонуса (например, "Реферальный бонус")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Заголовок для отображения пользователю
    #[prost(string, tag = "3")]
    pub title: ::prost::alloc::string::String,
    /// Описание для отображения пользователю
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, определяющая правила расчета и начисления бонуса.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Bonus`.
pub mod bonus {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID бонуса
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя бонуса
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Bonus>,
    }
}
/// Boundary определяет граничное значение и его тип (включительно или исключительно).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Boundary {
    /// Значение границы (например, "1000").
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// Тип границы (включительно/исключительно).
    #[prost(enumeration = "boundary::Kind", tag = "2")]
    pub kind: i32,
}
/// Nested message and enum types in `Boundary`.
pub mod boundary {
    /// Определяет, включается ли граничное значение в диапазон.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// Тип не указан.
        Unspecified = 0,
        /// Включительно (>= или <=).
        Inclusive = 1,
        /// Исключительно (> или <).
        Exclusive = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Inclusive => "INCLUSIVE",
                Self::Exclusive => "EXCLUSIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUSIVE" => Some(Self::Inclusive),
                "EXCLUSIVE" => Some(Self::Exclusive),
                _ => None,
            }
        }
    }
}
/// Rounding определяет полные правила математического округления.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rounding {
    /// Режим округления.
    #[prost(enumeration = "rounding::Kind", tag = "1")]
    pub kind: i32,
    /// Количество знаков для округления. Положительное - после запятой, отрицательное - до запятой.
    #[prost(sint32, tag = "2")]
    pub precision: i32,
}
/// Nested message and enum types in `Rounding`.
pub mod rounding {
    /// Определяет математический режим округления.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        /// Режим не указан.
        Unspecified = 0,
        /// Математическое округление (к ближайшему целому, .5 округляется вверх).
        HalfUp = 1,
        /// Округление в меньшую сторону (к полу, floor).
        Floor = 2,
        /// Округление в большую сторону (к потолку, ceiling).
        Ceiling = 3,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::HalfUp => "HALF_UP",
                Self::Floor => "FLOOR",
                Self::Ceiling => "CEILING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "HALF_UP" => Some(Self::HalfUp),
                "FLOOR" => Some(Self::Floor),
                "CEILING" => Some(Self::Ceiling),
                _ => None,
            }
        }
    }
}
/// Calculation является инструкцией для динамического расчета суммы.
/// Это не самостоятельная сущность, а встраиваемая модель для описания правил.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Calculation {
    /// Правила постобработки, применяемые к результату.
    #[prost(message, optional, tag = "4")]
    pub post_processing: ::core::option::Option<calculation::PostProcessing>,
    /// Определяет вид/структуру калькуляции.
    #[prost(oneof = "calculation::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<calculation::Kind>,
}
/// Nested message and enum types in `Calculation`.
pub mod calculation {
    /// Simple описывает простой, линейный расчет.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Simple {
        /// Фиксированная часть (например, "5.00" USDT).
        #[prost(string, tag = "1")]
        pub fixed_value: ::prost::alloc::string::String,
        /// Процентная часть (например, "0.01" для 1%).
        #[prost(string, tag = "2")]
        pub percent_value: ::prost::alloc::string::String,
    }
    /// Tiered описывает многоуровневый расчет.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tiered {
        #[prost(enumeration = "tiered::Mode", tag = "1")]
        pub mode: i32,
        #[prost(message, repeated, tag = "2")]
        pub tiers: ::prost::alloc::vec::Vec<tiered::Tier>,
    }
    /// Nested message and enum types in `Tiered`.
    pub mod tiered {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Tier {
            #[prost(message, optional, tag = "1")]
            pub lower_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "2")]
            pub upper_bound: ::core::option::Option<super::super::Boundary>,
            #[prost(message, optional, tag = "3")]
            pub calculation: ::core::option::Option<super::Simple>,
        }
        /// Определяет, как применяется расчет в многоуровневой шкале.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            Unspecified = 0,
            /// По достижению.
            Slab = 1,
            /// Прогрессивная.
            Progressive = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Slab => "SLAB",
                    Self::Progressive => "PROGRESSIVE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SLAB" => Some(Self::Slab),
                    "PROGRESSIVE" => Some(Self::Progressive),
                    _ => None,
                }
            }
        }
    }
    /// Conditional позволяет реализовать логику "if-else".
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Conditional {
        #[prost(message, optional, tag = "1")]
        pub condition: ::core::option::Option<super::Boundary>,
        #[prost(message, optional, boxed, tag = "2")]
        pub if_true: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
        #[prost(message, optional, boxed, tag = "3")]
        pub if_false: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::Calculation>,
        >,
    }
    /// PostProcessing определяет правила, применяемые к результату расчета.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PostProcessing {
        /// Минимальное значение результата (например, "комиссия не менее 10").
        #[prost(string, optional, tag = "1")]
        pub min_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Максимальное значение результата (например, "комиссия не более 100").
        #[prost(string, optional, tag = "2")]
        pub max_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Правила округления.
        #[prost(message, optional, tag = "3")]
        pub rounding: ::core::option::Option<super::Rounding>,
    }
    /// Определяет вид/структуру калькуляции.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Simple(Simple),
        #[prost(message, tag = "2")]
        Tiered(Tiered),
        #[prost(message, tag = "3")]
        Conditional(::prost::alloc::boxed::Box<Conditional>),
    }
}
/// CalculationGroup - это контейнер для нескольких независимых расчетов.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculationGroup {
    #[prost(map = "string, message", tag = "1")]
    pub calculations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Calculation,
    >,
    /// Правила постобработки, применяемые к ИТОГОВОЙ сумме.
    #[prost(message, optional, tag = "2")]
    pub post_processing: ::core::option::Option<calculation::PostProcessing>,
}
/// ConfirmationPolicy определяет набор правил для группы форм подтверждения.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmationPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни формы подтверждения в секундах.
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Максимальное количество попыток ввода данных.
    #[prost(uint32, tag = "5")]
    pub verification_attempt_limit: u32,
    /// Максимальное количество запросов на генерацию нового кода.
    #[prost(uint32, tag = "6")]
    pub code_generation_attempt_limit: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ConfirmationPolicy`.
pub mod confirmation_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ConfirmationPolicy>,
    }
}
/// Confirmation представляет собой одноразовую форму или сессию для подтверждения важного действия.
///
/// --- Вложенные типы и сообщения ----
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Confirmation {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID аккаунта, который инициировал действие.
    #[prost(uint32, tag = "2")]
    pub account_id: u32,
    /// Уникальное имя действия (например, "WITHDRAWAL").
    #[prost(string, tag = "3")]
    pub action_name: ::prost::alloc::string::String,
    #[prost(enumeration = "confirmation::Status", tag = "4")]
    pub status: i32,
    /// Описание или инструкция для пользователя.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Лимит попыток верификации для этой формы
    #[prost(uint32, tag = "6")]
    pub verification_attempt_limit: u32,
    /// Количество сделанных попыток верификации.
    #[prost(uint32, tag = "7")]
    pub verification_attempts_made: u32,
    /// Список всех доступных полей для этой формы.
    #[prost(message, repeated, tag = "8")]
    pub available_fields: ::prost::alloc::vec::Vec<confirmation::VerificationField>,
    /// Список групп верификации (нужно удовлетворить одну из них).
    #[prost(message, repeated, tag = "9")]
    pub verification_groups: ::prost::alloc::vec::Vec<confirmation::VerificationGroup>,
    #[prost(uint64, tag = "10")]
    pub trace_id: u64,
    /// Политика, управляющая правилами (время жизни, лимиты попыток).
    #[prost(uint32, tag = "11")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "12")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Точное время, когда форма станет недействительной (рассчитывается на основе политики).
    #[prost(message, optional, tag = "13")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "14")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Гибкое поле для дополнительных данных.
    #[prost(message, optional, tag = "15")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Confirmation`.
pub mod confirmation {
    /// Детали генерации кодов для полей типа EMAIL_CODE.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CodeGenerationDetails {
        /// Время, после которого можно запросить новый код.
        #[prost(message, optional, tag = "1")]
        pub next_generation_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Время генерации последнего кода.
        #[prost(message, optional, tag = "2")]
        pub last_generated_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Время, когда сгенерированный код станет недействительным.
        #[prost(message, optional, tag = "3")]
        pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Лимит доступных попыток генерации нового кода.
        #[prost(uint32, tag = "4")]
        pub generation_attempt_limit: u32,
        /// Количество уже сделанных попыток генерации.
        #[prost(uint32, tag = "5")]
        pub generation_attempts_made: u32,
    }
    /// Описание одного поля для верификации.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VerificationField {
        /// Уникальный ID поля в рамках формы.
        #[prost(uint32, tag = "1")]
        pub id: u32,
        /// Тип поля (пароль, 2FA, чекбокс и т.д.).
        #[prost(enumeration = "FieldKind", tag = "2")]
        pub kind: i32,
        /// Контакт для отправки кода (например, email), если применимо.
        #[prost(string, optional, tag = "3")]
        pub contact_info: ::core::option::Option<::prost::alloc::string::String>,
        /// Детали генерации кода (для EMAIL_CODE).
        #[prost(message, optional, tag = "4")]
        pub code_details: ::core::option::Option<CodeGenerationDetails>,
        /// Текст для чекбокса согласия.
        #[prost(string, optional, tag = "5")]
        pub agreement_text: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Группа верификации, описывающая один из возможных наборов полей для подтверждения.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VerificationGroup {
        /// Список ID полей (VerificationField.id), необходимых для этой группы.
        #[prost(uint32, repeated, tag = "1")]
        pub required_field_ids: ::prost::alloc::vec::Vec<u32>,
    }
    /// Идентификатор для поиска формы.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID формы.
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    /// Список форм подтверждения.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Confirmation>,
    }
    /// Запрос на генерацию одноразового кода для поля.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GenerateCodeRequest {
        /// ID формы подтверждения.
        #[prost(uint32, tag = "1")]
        pub confirmation_id: u32,
        /// ID поля, для которого нужно сгенерировать код.
        #[prost(uint32, tag = "2")]
        pub field_id: u32,
    }
    /// Запрос на подтверждение формы.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfirmRequest {
        /// Глобальный ID формы для подтверждения.
        #[prost(uint32, tag = "1")]
        pub confirmation_id: u32,
        /// Список полей, которые отправляет пользователь.
        #[prost(message, repeated, tag = "2")]
        pub submitted_fields: ::prost::alloc::vec::Vec<confirm_request::SubmittedField>,
    }
    /// Nested message and enum types in `ConfirmRequest`.
    pub mod confirm_request {
        /// Поле, предоставленное пользователем для верификации.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubmittedField {
            /// ID поля, которое заполняет пользователь.
            #[prost(uint32, tag = "1")]
            pub field_id: u32,
            #[prost(oneof = "submitted_field::Value", tags = "2, 3")]
            pub value: ::core::option::Option<submitted_field::Value>,
        }
        /// Nested message and enum types in `SubmittedField`.
        pub mod submitted_field {
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum Value {
                /// Значение для полей типа пароль, код и т.д.
                #[prost(string, tag = "2")]
                StringValue(::prost::alloc::string::String),
                /// Значение для чекбокса (должно быть `true`).
                #[prost(bool, tag = "3")]
                BoolValue(bool),
            }
        }
    }
    /// Ответ на запрос подтверждения формы.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConfirmResponse {
        /// Общий статус подтверждения.
        #[prost(enumeration = "confirm_response::OverallStatus", tag = "1")]
        pub status: i32,
        /// Детальный результат по каждому полю.
        #[prost(message, repeated, tag = "2")]
        pub field_results: ::prost::alloc::vec::Vec<confirm_response::FieldResult>,
        /// Дополнительные данные, возвращаемые при успехе.
        #[prost(message, optional, tag = "3")]
        pub data: ::core::option::Option<::prost_types::Any>,
    }
    /// Nested message and enum types in `ConfirmResponse`.
    pub mod confirm_response {
        /// Результат проверки для одного поля.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FieldResult {
            /// ID проверенного поля.
            #[prost(uint32, tag = "1")]
            pub field_id: u32,
            /// Статус проверки этого поля.
            #[prost(enumeration = "FieldStatus", tag = "2")]
            pub status: i32,
            /// Дополнительный комментарий об ошибке.
            #[prost(string, optional, tag = "3")]
            pub comment: ::core::option::Option<::prost::alloc::string::String>,
        }
        /// Общий статус ответа на запрос подтверждения.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum OverallStatus {
            Unspecified = 0,
            /// Форма отклонена (одно или несколько полей неверны).
            Rejected = 1,
            /// Форма успешно подтверждена.
            Approved = 2,
        }
        impl OverallStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OVERALL_STATUS_UNSPECIFIED",
                    Self::Rejected => "OVERALL_STATUS_REJECTED",
                    Self::Approved => "OVERALL_STATUS_APPROVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OVERALL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "OVERALL_STATUS_REJECTED" => Some(Self::Rejected),
                    "OVERALL_STATUS_APPROVED" => Some(Self::Approved),
                    _ => None,
                }
            }
        }
        /// Детальный статус для каждого отдельного поля.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FieldStatus {
            Unspecified = 0,
            /// Поле заполнено верно.
            Ok = 1,
            /// Поле не заполнено, но является обязательным.
            Empty = 2,
            /// Поле заполнено неверно.
            Wrong = 3,
            /// Срок действия значения поля истек (например, для кода).
            Expired = 4,
            /// Пользователь не согласился с условиями (чекбокс не `true`).
            NotAgreed = 5,
        }
        impl FieldStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FIELD_STATUS_UNSPECIFIED",
                    Self::Ok => "FIELD_STATUS_OK",
                    Self::Empty => "FIELD_STATUS_EMPTY",
                    Self::Wrong => "FIELD_STATUS_WRONG",
                    Self::Expired => "FIELD_STATUS_EXPIRED",
                    Self::NotAgreed => "FIELD_STATUS_NOT_AGREED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FIELD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "FIELD_STATUS_OK" => Some(Self::Ok),
                    "FIELD_STATUS_EMPTY" => Some(Self::Empty),
                    "FIELD_STATUS_WRONG" => Some(Self::Wrong),
                    "FIELD_STATUS_EXPIRED" => Some(Self::Expired),
                    "FIELD_STATUS_NOT_AGREED" => Some(Self::NotAgreed),
                    _ => None,
                }
            }
        }
    }
    /// Статус формы подтверждения.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Форма активна и ожидает подтверждения.
        Pending = 1,
        /// Форма была успешно подтверждена.
        Confirmed = 2,
        /// В верификации было отказано (например, исчерпаны попытки).
        Rejected = 3,
        /// Форма была отменена пользователем или системой.
        Cancelled = 4,
        /// Срок действия формы истек.
        Expired = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Pending => "STATUS_PENDING",
                Self::Confirmed => "STATUS_CONFIRMED",
                Self::Rejected => "STATUS_REJECTED",
                Self::Cancelled => "STATUS_CANCELLED",
                Self::Expired => "STATUS_EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_PENDING" => Some(Self::Pending),
                "STATUS_CONFIRMED" => Some(Self::Confirmed),
                "STATUS_REJECTED" => Some(Self::Rejected),
                "STATUS_CANCELLED" => Some(Self::Cancelled),
                "STATUS_EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
    /// Типы полей, которые могут потребоваться для подтверждения.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldKind {
        Unspecified = 0,
        /// Пароль от аккаунта пользователя.
        Password = 1,
        /// Код из приложения 2FA Google Authenticator.
        GoogleAuthenticatorCode = 2,
        /// Код, отправленный на email.
        EmailCode = 3,
        /// Чекбокс для подтверждения согласия с условиями.
        AgreementCheckbox = 4,
    }
    impl FieldKind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FIELD_KIND_UNSPECIFIED",
                Self::Password => "FIELD_KIND_PASSWORD",
                Self::GoogleAuthenticatorCode => "FIELD_KIND_GOOGLE_AUTHENTICATOR_CODE",
                Self::EmailCode => "FIELD_KIND_EMAIL_CODE",
                Self::AgreementCheckbox => "FIELD_KIND_AGREEMENT_CHECKBOX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIELD_KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "FIELD_KIND_PASSWORD" => Some(Self::Password),
                "FIELD_KIND_GOOGLE_AUTHENTICATOR_CODE" => {
                    Some(Self::GoogleAuthenticatorCode)
                }
                "FIELD_KIND_EMAIL_CODE" => Some(Self::EmailCode),
                "FIELD_KIND_AGREEMENT_CHECKBOX" => Some(Self::AgreementCheckbox),
                _ => None,
            }
        }
    }
}
/// CurrencyPolicy определяет набор правил для группы валют.
/// Конкретная логика политики (например, требования к KYC для операций) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrencyPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPolicy`.
pub mod currency_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPolicy>,
    }
}
/// Currency представляет собой финансовую единицу, такую как криптовалюта или фиат.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Currency {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название валюты (например, "Bitcoin")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный символ (тикер), например, "BTC"
    #[prost(string, tag = "3")]
    pub symbol: ::prost::alloc::string::String,
    /// Количество знаков после запятой для отображения и расчетов
    #[prost(uint32, tag = "4")]
    pub precision: u32,
    /// Текущий операционный статус валюты
    #[prost(enumeration = "currency::Status", tag = "5")]
    pub status: i32,
    #[prost(uint64, tag = "6")]
    pub trace_id: u64,
    /// Политика, управляющая поведением валюты
    #[prost(uint32, tag = "7")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Currency`.
pub mod currency {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID валюты
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный символ (тикер), например, "BTC"
            #[prost(string, tag = "2")]
            Symbol(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Currency>,
    }
    /// Определяет операционный статус валюты.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Доступна для всех операций.
        Active = 1,
        /// Только просмотр/вывод. Новые депозиты и торговые операции невозможны.
        ViewOnly = 2,
        /// Тех. обслуживание. Операции временно приостановлены.
        Maintenance = 3,
        /// Неактивна. Полностью отключена, но может быть активирована.
        Inactive = 4,
        /// Устарела. Валюта больше не поддерживается и сохранена только для истории.
        Deprecated = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ViewOnly => "VIEW_ONLY",
                Self::Maintenance => "MAINTENANCE",
                Self::Inactive => "INACTIVE",
                Self::Deprecated => "DEPRECATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "VIEW_ONLY" => Some(Self::ViewOnly),
                "MAINTENANCE" => Some(Self::Maintenance),
                "INACTIVE" => Some(Self::Inactive),
                "DEPRECATED" => Some(Self::Deprecated),
                _ => None,
            }
        }
    }
}
/// CurrencyPairPolicy определяет набор правил для группы валютных пар.
/// Конкретная логика политики (например, лимиты на торговлю, требования к марже) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrencyPairPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPairPolicy`.
pub mod currency_pair_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPairPolicy>,
    }
}
/// CurrencyPair представляет собой декларативную связь между двумя валютами.
/// Эта модель является справочной, но несет в себе операционный статус и ссылку на политику,
/// которые определяют правила для других систем, использующих эту пару (например, торговых).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CurrencyPair {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя пары (например, "BTC_USDT")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID базовой валюты (например, BTC)
    #[prost(uint32, tag = "3")]
    pub base_currency_id: u32,
    /// ID котируемой валюты (например, USDT)
    #[prost(uint32, tag = "4")]
    pub quote_currency_id: u32,
    /// Текущий операционный статус пары.
    #[prost(enumeration = "currency_pair::Status", tag = "5")]
    pub status: i32,
    /// Политика, управляющая правилами для этой пары.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `CurrencyPair`.
pub mod currency_pair {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID пары
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя пары, например, "BTC_USDT"
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::CurrencyPair>,
    }
    /// Определяет операционный статус торговой пары.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Торговля разрешена.
        Active = 1,
        /// Только просмотр. Новые ордера не принимаются, но можно просматривать историю.
        ViewOnly = 2,
        /// Тех. обслуживание. Торговля временно приостановлена.
        Maintenance = 3,
        /// Неактивна. Торговля приостановлена и может быть возобновлена.
        Inactive = 4,
        /// Устарела. Пара больше не поддерживается и скрыта из основных списков, но сохранена в системе для истории.
        Deprecated = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::ViewOnly => "VIEW_ONLY",
                Self::Maintenance => "MAINTENANCE",
                Self::Inactive => "INACTIVE",
                Self::Deprecated => "DEPRECATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "VIEW_ONLY" => Some(Self::ViewOnly),
                "MAINTENANCE" => Some(Self::Maintenance),
                "INACTIVE" => Some(Self::Inactive),
                "DEPRECATED" => Some(Self::Deprecated),
                _ => None,
            }
        }
    }
}
/// DistributorPolicy определяет набор правил для группы дистрибьюторов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorPolicy`.
pub mod distributor_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorPolicy>,
    }
}
/// Distributor представляет участника или узел в партнерской или дистрибьюторской сети.
/// Эта сущность связана с системным аккаунтом (Account) и может иметь иерархические связи.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Distributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное, человекочитаемое имя (псевдоним, бренд).
    #[prost(string, optional, tag = "2")]
    pub username: ::core::option::Option<::prost::alloc::string::String>,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "3")]
    pub parent_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "4")]
    pub parent_entity_id: u32,
    /// Числовой идентификатор ветки от вышестоящего дистрибьютора (parent_id)
    #[prost(uint32, tag = "5")]
    pub parent_branch_number: u32,
    /// ID сети, к которому относится дистрибьютор
    #[prost(uint32, tag = "6")]
    pub network_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
    #[prost(uint32, tag = "7")]
    pub network_entity_id: u32,
    /// ID аккаунта, владеющего дистрибьютором
    #[prost(uint32, tag = "8")]
    pub account_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
    #[prost(uint32, tag = "9")]
    pub account_entity_id: u32,
    /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
    #[prost(uint32, tag = "10")]
    pub network_account_entity_id: u32,
    /// ID партиции, к которому относится дистрибьютор
    #[prost(uint32, tag = "11")]
    pub network_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "12")]
    pub level: u32,
    /// Количество дочерних дистрибьюторов
    #[prost(uint32, tag = "13")]
    pub children_quantity: u32,
    /// Количество дистрибьюторов в структуре
    #[prost(uint32, tag = "14")]
    pub structure_quantity: u32,
    /// Последний ID дистрибьютора в структуре
    #[prost(uint32, tag = "15")]
    pub structure_last_id: u32,
    /// Максимальный уровень дистрибьютора в структуре
    #[prost(uint32, tag = "16")]
    pub structure_level_max: u32,
    #[prost(uint64, tag = "17")]
    pub trace_id: u64,
    /// ID политики, применяемой к этому дистрибьютору.
    #[prost(uint32, tag = "18")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "19")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "20")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "21")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Distributor`.
pub mod distributor {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дистрибьютора
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6, 7")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего дистрибьютора
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках вышестоящего дистрибьютора
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NetworkEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках сети (network_id)
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct AccountEntity {
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "1")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках аккаунта (account_id)
            #[prost(uint32, tag = "2")]
            pub account_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NetworkAccountEntity {
            /// ID сети, к которому относится дистрибьютор
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// ID аккаунта, владеющего дистрибьютором
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
            /// Порядковый идентификатор дистрибьютора в рамках пары (network_id и account_id)
            #[prost(uint32, tag = "3")]
            pub network_account_entity_id: u32,
        }
        /// Различные способы идентификации дистрибьютора
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дистрибьютора/бренда
            #[prost(string, tag = "2")]
            Username(::prost::alloc::string::String),
            #[prost(message, tag = "3")]
            ParentBranch(ParentBranch),
            #[prost(message, tag = "4")]
            ParentEntity(ParentEntity),
            #[prost(message, tag = "5")]
            NetworkEntity(NetworkEntity),
            #[prost(message, tag = "6")]
            AccountEntity(AccountEntity),
            #[prost(message, tag = "7")]
            NetworkAccountEntity(NetworkAccountEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Distributor>,
    }
}
/// DistributorBranchPolicy определяет набор правил для группы веток дистрибьюторов.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributorBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorBranchPolicy`.
pub mod distributor_branch_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranchPolicy>,
    }
}
/// DistributorBranch представляет собой иерархическую связь или "ветку" между дистрибьюторами.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributorBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего дистрибьютора
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего дистрибьютора
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего дистрибьютора, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `DistributorBranch`.
pub mod distributor_branch {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки дистрибьютора
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::distributor::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::DistributorBranch>,
    }
}
/// GoogleAuthenticatorPolicy определяет набор правил для группы настроек 2FA.
/// Конкретная логика политики (например, обязательность 2FA) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAuthenticatorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `GoogleAuthenticatorPolicy`.
pub mod google_authenticator_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticatorPolicy>,
    }
}
/// GoogleAuthenticator представляет собой настройки двухфакторной аутентификации (2FA) для пользователя.
/// Эта модель НЕ содержит секретный ключ из соображений безопасности.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAuthenticator {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID пользователя, для которого настроен 2FA
    #[prost(uint32, tag = "2")]
    pub user_id: u32,
    /// Текущий статус настройки 2FA
    #[prost(enumeration = "google_authenticator::Status", tag = "3")]
    pub status: i32,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    /// Политика, управляющая правилами 2FA
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `GoogleAuthenticator`.
pub mod google_authenticator {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// ID пользователя, к которому привязан 2FA
            #[prost(uint32, tag = "2")]
            UserId(u32),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::GoogleAuthenticator>,
    }
    /// Определяет статус настройки 2FA.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Неактивна. 2FA для пользователя не используется.
        Inactive = 1,
        /// Ожидает подтверждения. Пользователь отсканировал QR-код, но еще не ввел первый код для активации.
        PendingVerification = 2,
        /// Активна. 2FA включена и используется при входе и важных операциях.
        Active = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Inactive => "INACTIVE",
                Self::PendingVerification => "PENDING_VERIFICATION",
                Self::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "PENDING_VERIFICATION" => Some(Self::PendingVerification),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
/// Locale представляет собой языковую локаль, используемую в системе для интернационализации.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Locale {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Полное название (например, "English (United States)")
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный код по стандарту IETF BCP 47 (например, "en-US", "ar-SA").
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// Указывает, имеет ли язык написание справа налево (Right-to-Left).
    #[prost(bool, tag = "4")]
    pub is_rtl: bool,
    /// Текущий статус доступности локали
    #[prost(enumeration = "locale::Status", tag = "5")]
    pub status: i32,
    #[prost(uint64, tag = "6")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Locale`.
pub mod locale {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID локали
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальный код локали (например, "en-US")
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Locale>,
    }
    /// Определяет статус доступности локали.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Статус не определен.
        Unspecified = 0,
        /// Активна. Локаль доступна для выбора пользователями.
        Active = 1,
        /// Неактивна. Локаль скрыта и недоступна.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Network представляет собой основную партнерскую или дистрибьюторскую сеть.
/// Она служит контейнером для дистрибьюторов и их иерархических связей.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации сети
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID корневой партиции (NetworkPartition) для данной сети
    #[prost(uint32, tag = "3")]
    pub root_partition_id: u32,
    /// Политика, управляющая поведением всей сети.
    #[prost(uint32, tag = "4")]
    pub policy_id: u32,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Network`.
pub mod network {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации сети
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Различные способы идентификации сети
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID сети
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя сети
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Network>,
    }
}
/// NetworkPolicy определяет набор правил для группы сетей.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPolicy`.
pub mod network_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPolicy>,
    }
}
/// NetworkAccount представляет собой связь между сетью (Network) и универсальным аккаунтом (Account).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAccount {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер связи в рамках сети (network_id)
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// Идентификатор аккаунта
    #[prost(uint32, tag = "4")]
    pub account_id: u32,
    /// Порядковый номер связи в рамках аккаунта (account_id)
    #[prost(uint32, tag = "5")]
    pub account_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccount`.
pub mod network_account {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Идентификатор аккаунта
            #[prost(uint32, tag = "2")]
            pub account_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре сеть-аккаунт
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccount>,
    }
}
/// NetworkAccountPolicy определяет набор правил для группы связей NetworkAccount.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAccountPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkAccountPolicy`.
pub mod network_account_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkAccountPolicy>,
    }
}
/// NetworkPartition представляет собой выделенную часть или "партицию" внутри сети (Network).
/// Партиция начинается с определенного корневого дистрибьютора и может функционировать как отдельная подсеть.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительской сети
    #[prost(uint32, tag = "2")]
    pub network_id: u32,
    /// Порядковый номер партиции в рамках сети
    #[prost(uint32, tag = "3")]
    pub network_entity_id: u32,
    /// ID корневого дистрибьютора, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_distributor_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartition`.
pub mod network_partition {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в сети
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор партиции в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartition>,
    }
}
/// NetworkPartitionPolicy определяет набор правил для группы партиций сети.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "89")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `NetworkPartitionPolicy`.
pub mod network_partition_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::NetworkPartitionPolicy>,
    }
}
/// ReferralLinkPolicy определяет набор правил для группы реферальных ссылок.
/// Для коллективных ссылок, эта политика может описывать логику балансировщика.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferralLinkPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint64, tag = "2")]
    pub trace_id: u64,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ReferralLinkPolicy`.
pub mod referral_link_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ReferralLinkPolicy>,
    }
}
/// ReferralLink представляет собой реферальную ссылку, используемую для привлечения новых участников.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferralLink {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// Имя ссылки, видимое ее создателю.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Уникальный код, используемый в URL (например, "REF123XYZ").
    #[prost(string, tag = "3")]
    pub code: ::prost::alloc::string::String,
    /// Тип ссылки (персональная или коллективная).
    #[prost(enumeration = "referral_link::Kind", tag = "4")]
    pub kind: i32,
    /// Статус ссылки (активна/неактивна).
    #[prost(enumeration = "referral_link::Status", tag = "5")]
    pub status: i32,
    /// ID аккаунта, который является создателем и владельцем этой ссылки.
    #[prost(uint32, tag = "6")]
    pub account_id: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    /// Политика, управляющая правилами ссылки.
    #[prost(uint32, tag = "8")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `ReferralLink`.
pub mod referral_link {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            #[prost(uint64, tag = "1")]
            Id(u64),
            /// Уникальный код ссылки.
            #[prost(string, tag = "2")]
            Code(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ReferralLink>,
    }
    /// Тип реферальной ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        /// Персональная: всегда ведет к дистрибьютору, связанному с аккаунтом-владельцем.
        Personal = 1,
        /// Коллективная: использует внутреннюю логику (определяемую политикой) для определения конечного дистрибьютора.
        Collective = 2,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KIND_UNSPECIFIED",
                Self::Personal => "KIND_PERSONAL",
                Self::Collective => "KIND_COLLECTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KIND_UNSPECIFIED" => Some(Self::Unspecified),
                "KIND_PERSONAL" => Some(Self::Personal),
                "KIND_COLLECTIVE" => Some(Self::Collective),
                _ => None,
            }
        }
    }
    /// Статус жизненного цикла ссылки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Активна и может быть использована для регистрации.
        Active = 1,
        /// Неактивна и не может быть использована.
        Inactive = 2,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Active => "STATUS_ACTIVE",
                Self::Inactive => "STATUS_INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_ACTIVE" => Some(Self::Active),
                "STATUS_INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Relationship представляет собой результат проверки иерархической связи между двумя объектами.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Relationship {
    /// Базовый ID элемента, от которого строим отношение.
    #[prost(uint32, tag = "1")]
    pub base_id: u32,
    /// ID целевого элемента, чье отношение к базовому описывается.
    #[prost(uint32, tag = "2")]
    pub target_id: u32,
    /// Состояние отношения между базовым и целевым элементами.
    #[prost(message, optional, tag = "3")]
    pub state: ::core::option::Option<relationship::State>,
}
/// Nested message and enum types in `Relationship`.
pub mod relationship {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct State {
        /// Тип отношения между объектами.
        #[prost(enumeration = "state::Kind", tag = "1")]
        pub kind: i32,
        /// Разница в уровнях (для TEAM и UPLINE).
        #[prost(uint32, optional, tag = "4")]
        pub level_diff: ::core::option::Option<u32>,
        /// Номер ветки, в которой находится дочерний объект (для TEAM).
        #[prost(uint32, optional, tag = "5")]
        pub branch_number: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `State`.
    pub mod state {
        /// Определяет тип иерархической связи.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Kind {
            /// Отношение не определено (например, один из объектов не найден).
            Unspecified = 0,
            /// Тот же самый объект (сравнение объекта с самим собой).
            Personal = 1,
            /// Целевой объект является дочерним по отношению к базовому (в его команде).
            Team = 2,
            /// Целевой объект является родительским по отношению к базовому (в его спонсорской линии).
            Upline = 3,
            /// Объекты находятся в одной иерархии, но не связаны по вертикали (например, "братья").
            Sideways = 4,
            /// Объекты находятся в разных, не связанных иерархиях.
            Separate = 5,
        }
        impl Kind {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Personal => "PERSONAL",
                    Self::Team => "TEAM",
                    Self::Upline => "UPLINE",
                    Self::Sideways => "SIDEWAYS",
                    Self::Separate => "SEPARATE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "PERSONAL" => Some(Self::Personal),
                    "TEAM" => Some(Self::Team),
                    "UPLINE" => Some(Self::Upline),
                    "SIDEWAYS" => Some(Self::Sideways),
                    "SEPARATE" => Some(Self::Separate),
                    _ => None,
                }
            }
        }
    }
}
/// SessionPolicy определяет набор правил безопасности и времени жизни для группы сессий.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Время жизни сессии в секундах. 0 означает "бессрочная".
    #[prost(uint32, tag = "4")]
    pub expires_in_seconds: u32,
    /// Время неактивности в секундах, после которого сессия истекает. 0 означает "не проверять".
    #[prost(uint32, tag = "5")]
    pub inactivity_timeout_seconds: u32,
    /// Максимальное количество одновременных активных сессий для одного пользователя.
    #[prost(uint32, tag = "6")]
    pub max_concurrent_sessions: u32,
    /// Требовать ли, чтобы IP-адрес сессии не менялся.
    #[prost(bool, tag = "7")]
    pub bind_to_ip: bool,
    #[prost(uint64, tag = "8")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SessionPolicy`.
pub mod session_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SessionPolicy>,
    }
}
/// Session представляет собой активную сессию пользователя в системе.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// ID пользователя, которому принадлежит сессия.
    #[prost(uint32, tag = "2")]
    pub user_id: u32,
    /// Текущий статус сессии.
    #[prost(enumeration = "session::Status", tag = "3")]
    pub status: i32,
    /// Информация об устройстве.
    #[prost(message, optional, tag = "4")]
    pub device: ::core::option::Option<session::Device>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая правилами этой сессии.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Точное время, когда сессия станет недействительной.
    #[prost(message, optional, tag = "9")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Время последнего действия пользователя в этой сессии.
    #[prost(message, optional, tag = "10")]
    pub last_activity_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Session`.
pub mod session {
    /// Информация об устройстве и клиенте, с которого была начата сессия.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Device {
        /// IP-адрес, с которого была создана сессия.
        #[prost(string, tag = "1")]
        pub ip_address: ::prost::alloc::string::String,
        /// Полная строка User-Agent.
        #[prost(string, tag = "2")]
        pub user_agent: ::prost::alloc::string::String,
        /// Приблизительное местоположение (например, "City, Country"), полученное по IP.
        #[prost(string, optional, tag = "3")]
        pub location: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Глобальный ID сессии.
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Session>,
    }
    /// Статус жизненного цикла сессии.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        /// Сессия активна и используется.
        Active = 1,
        /// Срок действия сессии истек (по времени или неактивности).
        Expired = 2,
        /// Сессия была завершена пользователем (logout).
        Cancelled = 3,
        /// Сессия была принудительно завершена системой (например, при входе с нового устройства).
        Revoked = 4,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Expired => "EXPIRED",
                Self::Cancelled => "CANCELLED",
                Self::Revoked => "REVOKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "EXPIRED" => Some(Self::Expired),
                "CANCELLED" => Some(Self::Cancelled),
                "REVOKED" => Some(Self::Revoked),
                _ => None,
            }
        }
    }
}
/// SlotPolicy определяет набор правил для группы слотов.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Уникальный идентификатор операции, в рамках которой был создан объект
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotPolicy`.
pub mod slot_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotPolicy>,
    }
}
/// Slot представляет собой ячейку или позицию в иерархической структуре (Tree).
/// Каждый слот принадлежит определенному дистрибьютору (Distributor).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Slot {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
    #[prost(uint32, tag = "3")]
    pub parent_entity_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
    #[prost(uint32, tag = "4")]
    pub parent_branch_number: u32,
    /// ID дерева, к которому относится слот
    #[prost(uint32, tag = "5")]
    pub tree_id: u32,
    /// Порядковый идентификатор слота в рамках дерева (tree_id)
    #[prost(uint32, tag = "6")]
    pub tree_entity_id: u32,
    /// ID дистрибьютора, владеющего слотом
    #[prost(uint32, tag = "7")]
    pub distributor_id: u32,
    /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "8")]
    pub distributor_entity_id: u32,
    /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
    #[prost(uint32, tag = "9")]
    pub tree_distributor_entity_id: u32,
    /// ID партиции, к которому относится слот
    #[prost(uint32, tag = "10")]
    pub tree_partition_id: u32,
    /// Глобальный уровень глубины
    #[prost(uint32, tag = "11")]
    pub level: u32,
    /// Количество дочерних слотов
    #[prost(uint32, tag = "12")]
    pub children_quantity: u32,
    /// Вместимость дочерних слотов
    #[prost(uint32, tag = "13")]
    pub children_capacity: u32,
    /// Количество слотов в структуре
    #[prost(uint32, tag = "14")]
    pub structure_quantity: u32,
    /// Вместимость слотов в структуре
    #[prost(uint64, tag = "15")]
    pub structure_capacity: u64,
    /// Последний ID слота в структуре
    #[prost(uint32, tag = "16")]
    pub structure_last_id: u32,
    /// Максимальный уровень слота в структуре
    #[prost(uint32, tag = "17")]
    pub structure_level_max: u32,
    #[prost(uint64, tag = "18")]
    pub trace_id: u64,
    /// ID политики, применяемой к этому слоту.
    #[prost(uint32, tag = "19")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "20")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "21")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "22")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Slot`.
pub mod slot {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации слота
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3, 4, 5, 6")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ParentBranch {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Числовой идентификатор ветки от вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_branch_number: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct ParentEntity {
            /// ID вышестоящего слота
            #[prost(uint32, tag = "1")]
            pub parent_id: u32,
            /// Порядковый идентификатор слота в рамках вышестоящего слота (parent_id)
            #[prost(uint32, tag = "2")]
            pub parent_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TreeEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор слота в рамках дерева (tree_id)
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DistributorEntity {
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "1")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках дистрибьютора (distributor_id)
            #[prost(uint32, tag = "2")]
            pub distributor_entity_id: u32,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TreeDistributorEntity {
            /// ID дерева, к которому относится слот
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// ID дистрибьютора, владеющего слотом
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
            /// Порядковый идентификатор слота в рамках пары (tree_id и distributor_id)
            #[prost(uint32, tag = "3")]
            pub tree_distributor_entity_id: u32,
        }
        /// Различные способы идентификации слота
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по вышестоящему слоту и номеру ветки
            #[prost(message, tag = "2")]
            ParentBranch(ParentBranch),
            /// Идентификация слота через комбинацию ID вышестоящего слота и порядкового идентификатора слота в рамках вышестоящего слота
            #[prost(message, tag = "3")]
            ParentEntity(ParentEntity),
            /// Идентификация слота через комбинацию ID дерева и порядкового идентификатора слота в рамках этого дерева
            #[prost(message, tag = "4")]
            TreeEntity(TreeEntity),
            /// Идентификация слота через комбинацию ID дистрибьютора и порядкового идентификатора слота в рамках этого дистрибьютора
            #[prost(message, tag = "5")]
            DistributorEntity(DistributorEntity),
            /// Идентификация слота через комбинацию ID дерева, ID дистрибьютора и порядкового идентификатора слота в рамках этой пары
            #[prost(message, tag = "6")]
            TreeDistributorEntity(TreeDistributorEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Slot>,
    }
}
/// SlotBranchPolicy определяет набор правил для группы веток слотов.
/// Конкретная логика политики (например, начисление особых бонусов) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotBranchPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotBranchPolicy`.
pub mod slot_branch_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranchPolicy>,
    }
}
/// SlotBranch представляет собой иерархическую связь или "ветку" между слотами.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlotBranch {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID вышестоящего слота
    #[prost(uint32, tag = "2")]
    pub parent_id: u32,
    /// Числовой идентификатор ветки от вышестоящего слота
    #[prost(uint32, tag = "3")]
    pub parent_branch_number: u32,
    /// ID дочернего слота, если ветка занята
    #[prost(uint32, optional, tag = "4")]
    pub child_id: ::core::option::Option<u32>,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    /// Политика, управляющая поведением ветки (например, начисление бонусов).
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `SlotBranch`.
pub mod slot_branch {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID ветки слота
            #[prost(uint32, tag = "1")]
            Id(u32),
            #[prost(message, tag = "2")]
            ParentBranch(super::super::slot::id::ParentBranch),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::SlotBranch>,
    }
}
/// Sort определяет порядок и количество записей в запросах на получение списков.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Sort {
    /// Направление сортировки.
    #[prost(enumeration = "sort::Direction", tag = "1")]
    pub direction: i32,
    /// Лимит записей (например, для пагинации).
    #[prost(uint32, tag = "2")]
    pub limit: u32,
}
/// Nested message and enum types in `Sort`.
pub mod sort {
    /// Направление сортировки.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        /// Направление не указано. Поведение по умолчанию (обычно BACKWARD) определяется на бэкенде.
        Unspecified = 0,
        /// Прямой порядок (от старых к новым, от меньшего ID к большему).
        Forward = 1,
        /// Обратный порядок (от новых к старым, от большего ID к меньшему).
        Backward = 2,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Forward => "FORWARD",
                Self::Backward => "BACKWARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "FORWARD" => Some(Self::Forward),
                "BACKWARD" => Some(Self::Backward),
                _ => None,
            }
        }
    }
}
/// Subject представляет собой субъект или объект, над которым было совершено действие.
/// Это типобезопасный указатель на любую ключевую сущность в системе.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Subject {
    #[prost(oneof = "subject::Entity", tags = "1, 2, 3")]
    pub entity: ::core::option::Option<subject::Entity>,
}
/// Nested message and enum types in `Subject`.
pub mod subject {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Entity {
        #[prost(uint32, tag = "1")]
        AccountId(u32),
        #[prost(uint32, tag = "2")]
        CurrencyId(u32),
        /// ... и другие важные сущности могут быть добавлены в будущем
        #[prost(uint32, tag = "3")]
        BonusId(u32),
    }
}
/// Trace представляет собой полную трассировку одной бизнес-операции, состоящую из плоского списка шагов (spans).
/// Иерархия шагов строится на клиенте с использованием поля `parent_id`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    /// Глобальный УНИКАЛЬНЫЙ ID всей бизнес-операции.
    #[prost(uint64, tag = "1")]
    pub trace_id: u64,
    /// Аккаунт, который ИНИЦИИРОВАЛ всю операцию. Если пуст - действие системное.
    #[prost(uint32, optional, tag = "2")]
    pub actor_id: ::core::option::Option<u32>,
    /// Плоский список всех шагов, произошедших в рамках этой операции.
    #[prost(message, repeated, tag = "3")]
    pub spans: ::prost::alloc::vec::Vec<trace::Span>,
}
/// Nested message and enum types in `Trace`.
pub mod trace {
    /// Span представляет один, конкретный, атомарный шаг (операцию) в трассировке.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Span {
        /// Уникальный ID самого шага (span'а).
        #[prost(uint64, tag = "1")]
        pub id: u64,
        /// ID родительского шага. Равен 0 для корневого шага.
        #[prost(uint64, tag = "2")]
        pub parent_id: u64,
        /// Техническое имя операции (например, "CreateLedgerTransaction").
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        /// Статус выполнения этого шага.
        #[prost(enumeration = "span::Status", tag = "4")]
        pub status: i32,
        /// Сообщение об ошибке, если status = FAILURE.
        #[prost(string, optional, tag = "5")]
        pub error_message: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "6")]
        pub started_at: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "7")]
        pub finished_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Контекст, специфичный для этого шага (например, ID созданной транзакции, сумма и т.д.).
        #[prost(message, optional, tag = "8")]
        pub context: ::core::option::Option<::prost_types::Any>,
    }
    /// Nested message and enum types in `Span`.
    pub mod span {
        /// Статус выполнения шага.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Status {
            Unspecified = 0,
            /// Шаг успешно выполнен.
            Success = 1,
            /// В процессе выполнения шага произошла ошибка.
            Failure = 2,
        }
        impl Status {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Success => "SUCCESS",
                    Self::Failure => "FAILURE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCESS" => Some(Self::Success),
                    "FAILURE" => Some(Self::Failure),
                    _ => None,
                }
            }
        }
    }
}
/// TreePolicy определяет набор правил для группы деревьев.
/// Конкретная логика политики реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreePolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePolicy`.
pub mod tree_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePolicy>,
    }
}
/// Tree представляет собой основную иерархическую структуру или сеть.
/// Она служит контейнером для слотов, дистрибьюторов и партиций.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tree {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное строковое имя для идентификации дерева
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// ID сети, к которой принадлежит дерево
    #[prost(uint32, tag = "3")]
    pub network_id: u32,
    /// Порядковый идентификатор дерева в рамках сети (network_id)
    #[prost(uint32, tag = "4")]
    pub network_entity_id: u32,
    /// ID корневой партиции (TreePartition) для данного дерева
    #[prost(uint32, tag = "5")]
    pub root_partition_id: u32,
    /// Вместимость дочерних слотов по умолчанию. Используется для визуализации структуры.
    #[prost(uint32, tag = "6")]
    pub slot_children_capacity_default: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    /// Политика, управляющая поведением всего дерева.
    #[prost(uint32, tag = "8")]
    pub policy_id: u32,
    #[prost(message, optional, tag = "9")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `Tree`.
pub mod tree {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации дерева
        #[prost(oneof = "id::Identifier", tags = "1, 2, 3")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по сети и порядковому номеру
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NetworkEntity {
            /// Идентификатор сети
            #[prost(uint32, tag = "1")]
            pub network_id: u32,
            /// Порядковый идентификатор дерева в рамках сети
            #[prost(uint32, tag = "2")]
            pub network_entity_id: u32,
        }
        /// Различные способы идентификации дерева
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID дерева
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя дерева
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
            /// Идентификация по сети и порядковому номеру
            #[prost(message, tag = "3")]
            NetworkEntity(NetworkEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Tree>,
    }
}
/// TreeDistributorPolicy определяет набор правил для группы связей TreeDistributor.
/// Конкретная логика политики (например, блокировка, особые условия) реализуется на бэкенде.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeDistributorPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreeDistributorPolicy`.
pub mod tree_distributor_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributorPolicy>,
    }
}
/// TreeDistributor представляет собой связь между деревом (Tree) и дистрибьютором (Distributor).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeDistributor {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Идентификатор дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер связи в рамках дерева (tree_id)
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// Идентификатор дистрибьютора
    #[prost(uint32, tag = "4")]
    pub distributor_id: u32,
    /// Порядковый номер связи в рамках дистрибьютора (distributor_id)
    #[prost(uint32, tag = "5")]
    pub distributor_entity_id: u32,
    /// ID политики, применяемой к этой связи. Определяет ее статус и правила.
    #[prost(uint32, tag = "6")]
    pub policy_id: u32,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreeDistributor`.
pub mod tree_distributor {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации связи
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Составной идентификатор для связи
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Pair {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Идентификатор дистрибьютора
            #[prost(uint32, tag = "2")]
            pub distributor_id: u32,
        }
        /// Различные способы идентификации связи
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID связи
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по паре дерево-дистрибьютор
            #[prost(message, tag = "2")]
            Pair(Pair),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreeDistributor>,
    }
}
/// TreePartitionPolicy определяет набор правил для группы партиций дерева.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreePartitionPolicy {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Уникальное имя политики для идентификации
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Описание, поясняющее суть и логику работы политики
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Определяет, могут ли партиции, подчиненные этой политике, быть слиты с другими. false - аналог "Standalone".
    #[prost(bool, tag = "4")]
    pub is_mergeable: bool,
    #[prost(uint64, tag = "5")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePartitionPolicy`.
pub mod tree_partition_policy {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Id {
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID политики
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Уникальное имя политики
            #[prost(string, tag = "2")]
            Name(::prost::alloc::string::String),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartitionPolicy>,
    }
}
/// TreePartition представляет собой выделенную часть или "партицию" внутри дерева (Tree).
/// Партиция начинается с определенного корневого слота и может функционировать как отдельное поддерево.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreePartition {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID родительского дерева
    #[prost(uint32, tag = "2")]
    pub tree_id: u32,
    /// Порядковый номер партиции в рамках дерева
    #[prost(uint32, tag = "3")]
    pub tree_entity_id: u32,
    /// ID корневого слота, с которого начинается партиция
    #[prost(uint32, tag = "4")]
    pub root_slot_id: u32,
    /// Политика, управляющая поведением партиции (например, возможностью слияния).
    #[prost(uint32, tag = "5")]
    pub policy_id: u32,
    /// Флаг, указывающий, что партиция была слита с другой и больше не активна.
    #[prost(bool, tag = "6")]
    pub is_archived: bool,
    #[prost(uint64, tag = "7")]
    pub trace_id: u64,
    #[prost(message, optional, tag = "8")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub additional_data: ::core::option::Option<::prost_types::Any>,
}
/// Nested message and enum types in `TreePartition`.
pub mod tree_partition {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Id {
        /// Различные способы идентификации партиции
        #[prost(oneof = "id::Identifier", tags = "1, 2")]
        pub identifier: ::core::option::Option<id::Identifier>,
    }
    /// Nested message and enum types in `Id`.
    pub mod id {
        /// Идентификация по порядковому номеру в дереве
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TreeEntity {
            /// Идентификатор дерева
            #[prost(uint32, tag = "1")]
            pub tree_id: u32,
            /// Порядковый идентификатор партиции в рамках дерева
            #[prost(uint32, tag = "2")]
            pub tree_entity_id: u32,
        }
        /// Различные способы идентификации партиции
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Identifier {
            /// Глобальный ID партиции
            #[prost(uint32, tag = "1")]
            Id(u32),
            /// Идентификация по дереву и порядковому номеру
            #[prost(message, tag = "2")]
            Entity(TreeEntity),
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::TreePartition>,
    }
}
